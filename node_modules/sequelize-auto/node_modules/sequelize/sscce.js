'use strict';

const Sequelize = require('./index');
const sequelize = require('./test/support').createSequelizeInstance();

const Uuid = require('uuid');

const User = sequelize.define('User', {
  uid: { type: Sequelize.UUID, primaryKey: true }
});
const Project = sequelize.define('Project', {
  pid: { type: Sequelize.UUID, primaryKey: true }
});

const UserProject = sequelize.define('UserProject', {
  upid: { type: Sequelize.UUID, primaryKey: true },
  UserId: { type: Sequelize.UUID, allowNull: false },
  ProjectId: { type: Sequelize.UUID, allowNull: false }
});

User.belongsToMany(Project, {
  through: { model: UserProject, unique: false },
  foreignKey: 'UserId'
});
Project.belongsToMany(User, {
  through: { model: UserProject, unique: false },
  foreignKey: 'ProjectId'
});

const usrId = '8530750e-c8b8-4054-a063-b7d2ff44fa4b';
const prjId = 'ec684969-aeb7-486b-b84b-457be634c57e';
const upIdA = 'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa';
const upIdB = 'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb';

const testcase = Number(process.argv[2]);

switch (testcase) {
  case 0:
    console.log(
      'Test case 0: re-creation of test case for issue #2459.  See: https://github.com/sequelize/sequelize/issues/2459'
    );
    console.log(
      'This test case passes only because the two add operations are parallelized.'
    );
    sequelize
      .sync({ force: true })
      .then(() => {
        sequelize.Promise.join(
          User.create({ uid: usrId }),
          Project.create({ pid: prjId })
        ).spread((usr, prj) =>
          Sequelize.Promise.join(
            usr.addProject(prj, { through: { upid: Uuid.v4() } }),
            usr.addProject(prj, { through: { upid: Uuid.v4() } })
          )
            .then(() => usr.getProjects({ raw: true }))
            .then(msg => {
              console.log(msg);
              sequelize.close();
            })
        );
      })
      .catch(err => {
        console.log(err);
        sequelize.close();
      });
    break;

  case 1:
    console.log(
      'Test case 1: extension of test case #0 which attempts to add additional records.'
    );
    console.log(
      'Demonstrates incorrect validation, and incorrect validation error message.'
    );
    sequelize
      .sync({ force: true })
      .then(() => {
        sequelize.Promise.join(
          User.create({ uid: usrId }),
          Project.create({ pid: prjId })
        ).spread((usr, prj) =>
          Sequelize.Promise.join(
            usr.addProject(prj, { through: { upid: Uuid.v4() } }),
            usr.addProject(prj, { through: { upid: Uuid.v4() } })
          )
            .then(() => usr.getProjects({ raw: true }))
            .then(msg => {
              console.log(msg);
            })
            .then(() => {
              sequelize.Promise.join(
                User.findById(usrId),
                Project.findById(prjId)
              ).spread((usr1, prj1) => {
                usr1
                  .addProject(prj1, { through: { upid: upIdA } })
                  .then(() => {
                    usr1
                      .addProject(prj1, { through: { upid: upIdB } })
                      .then(() => usr1.getProjects({ raw: true }))
                      .then(msg1 => {
                        console.log(msg1);
                        sequelize.close();
                      });
                  })
                  .catch(err => {
                    console.log(err);
                    sequelize.close();
                  });
              });
            })
        );
      })
      .catch(err => {
        console.log(err);
        sequelize.close();
      });
    break;

  case 2:
    console.log(
      'Test case 2: Alternative form of test case #0, demonstrating that sequential add operations fail.'
    );
    sequelize
      .sync({ force: true })
      .then(() => {
        sequelize.Promise.all([
          User.create({ uid: usrId }),
          Project.create({ pid: prjId })
        ]).spread((usr, prj) => {
          usr.addProject(prj, { through: { upid: Uuid.v4() } }).then(() => {
            usr
              .addProject(prj, { through: { upid: Uuid.v4() } })
              .then(() => usr.getProjects({ raw: true }))
              .then(msg1 => {
                console.log(msg1);
                sequelize.close();
              });
          });
        });
      })
      .catch(err => {
        console.log(err);
        sequelize.close();
      });
    break;

  case 3:
    console.log(
      'Test case 3: Extension of test case #2: the database is NOT cleared, demonstrating that add operations overwrite existing entries.'
    );
    sequelize.Promise.join(User.findById(usrId), Project.findById(prjId))
      .spread((usr, prj) => {
        usr.addProject(prj, { through: { upid: Uuid.v4() } }).then(() => {
          usr
            .addProject(prj, { through: { upid: Uuid.v4() } })
            .then(() => usr.getProjects({ raw: true }))
            .then(msg1 => {
              console.log(msg1);
              sequelize.close();
            });
        });
      })
      .catch(err => {
        console.log(err);
        sequelize.close();
      });
    break;
}
